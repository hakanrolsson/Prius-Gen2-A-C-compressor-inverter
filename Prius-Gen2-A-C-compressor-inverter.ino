// Pin Definitions
const int clockPin = 13;     // SPI Clock Pin (active low)
const int dataInPin = 11;    // Data Pin for receiving data
const int dataOutPin = 12;   // Data Pin for sending response
const int chipSelectPin = 10; // Chip Select Pin
const int packetSize = 10;  // Number of bytes in a packet

// Timing Definitions
const unsigned long clockCycleTime = 3200;      // Clock cycle time in microseconds (3.2ms)
const unsigned long byteReceiveTime = 26000;    // Time to receive one byte (26ms)
const unsigned long packetGapTime = 80000;      // Time between packets (80ms)

// Fixed Response Data
byte responseData[108][packetSize] = {{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0x76, 0x77, 0xFE, 0xFF, 0x44, 0x76, 0x77, 0xFE, 0xFF, 0x44},
{0x76, 0x77, 0xFE, 0xFF, 0x44, 0x76, 0x77, 0xFE, 0xFF, 0x44},
{0x8E, 0x77, 0xFE, 0xFF, 0xF8, 0x8E, 0x77, 0xFE, 0xFF, 0xF8},
{0x8E, 0x77, 0xFE, 0xFF, 0xF8, 0x8E, 0x77, 0xFE, 0xFF, 0xF8},
{0x8E, 0x77, 0xFE, 0xFF, 0xF8, 0x8E, 0x77, 0xFE, 0xFF, 0xF8},
{0x2E, 0x77, 0xFE, 0xFF, 0x38, 0x2E, 0x77, 0xFE, 0xFF, 0x38},
{0x2E, 0x77, 0xFE, 0xFF, 0x38, 0x2E, 0x77, 0xFE, 0xFF, 0x38},
{0xEE, 0x77, 0xFE, 0xFF, 0x98, 0xEE, 0x77, 0xFE, 0xFF, 0x98},
{0xEE, 0x77, 0xFE, 0xFF, 0x98, 0xEE, 0x77, 0xFE, 0xFF, 0x98},
{0xEE, 0x77, 0xFE, 0xFF, 0x98, 0xEE, 0x77, 0xFE, 0xFF, 0x98},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xF6, 0x77, 0xFE, 0xFF, 0x84, 0xF6, 0x77, 0xFE, 0xFF, 0x84},
{0xF6, 0x77, 0xFE, 0xFF, 0x84, 0xF6, 0x77, 0xFE, 0xFF, 0x84},
{0xCE, 0x77, 0xFE, 0xFF, 0xB8, 0xCE, 0x77, 0xFE, 0xFF, 0xB8},
{0xCE, 0x77, 0xFE, 0xFF, 0xB8, 0xCE, 0x77, 0xFE, 0xFF, 0xB8},
{0xCE, 0x77, 0xFE, 0xFF, 0xB8, 0xCE, 0x77, 0xFE, 0xFF, 0xB8},
{0xEE, 0x77, 0xFE, 0xFF, 0x98, 0xEE, 0x77, 0xFE, 0xFF, 0x98},
{0xEE, 0x77, 0xFE, 0xFF, 0x98, 0xEE, 0x77, 0xFE, 0xFF, 0x98},
{0xDE, 0x77, 0xFE, 0xFF, 0xA8, 0xDE, 0x77, 0xFE, 0xFF, 0xA8},
{0xDE, 0x77, 0xFE, 0xFF, 0xA8, 0xDE, 0x77, 0xFE, 0xFF, 0xA8},
{0xDE, 0x77, 0xFE, 0xFF, 0xA8, 0xDE, 0x77, 0xFE, 0xFF, 0xA8},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xD6, 0x77, 0xFE, 0xFF, 0xA4, 0xD6, 0x77, 0xFE, 0xFF, 0xA4},
{0xC1, 0x57, 0xFE, 0xFF, 0x88, 0xC1, 0x57, 0xFE, 0xFF, 0x88},
{0xC1, 0x57, 0xFE, 0xFF, 0x88, 0xC1, 0x57, 0xFE, 0xFF, 0x88},
{0xC1, 0x57, 0xFE, 0xFF, 0x88, 0xC1, 0x57, 0xFE, 0xFF, 0x88},
{0xF2, 0x57, 0xFE, 0xFF, 0xA2, 0xF2, 0x57, 0xFE, 0xFF, 0xA2},
{0xF2, 0x57, 0xFE, 0xFF, 0xA2, 0xF2, 0x57, 0xFE, 0xFF, 0xA2},
{0xD8, 0x57, 0xFE, 0xFF, 0x9E, 0xD8, 0x57, 0xFE, 0xFF, 0x9E},
{0xD8, 0x57, 0xFE, 0xFF, 0x9E, 0xD8, 0x57, 0xFE, 0xFF, 0x9E},
{0xD8, 0x57, 0xFE, 0xFF, 0x9E, 0xD8, 0x57, 0xFE, 0xFF, 0x9E},
{0xE7, 0x97, 0xFE, 0xFF, 0x75, 0xE7, 0x97, 0xFE, 0xFF, 0x75},
{0xE7, 0x97, 0xFE, 0xFF, 0x75, 0xE7, 0x97, 0xFE, 0xFF, 0x75},
{0xCD, 0x97, 0xFE, 0xFF, 0x47, 0xCD, 0x97, 0xFE, 0xFF, 0x47},
{0xCD, 0x97, 0xFE, 0xFF, 0x47, 0xCD, 0x97, 0xFE, 0xFF, 0x47},
{0xCD, 0x97, 0xFE, 0xFF, 0x47, 0xCD, 0x97, 0xFE, 0xFF, 0x47},
{0xFE, 0x97, 0xFE, 0xFF, 0x68, 0xFE, 0x97, 0xFE, 0xFF, 0x68},
{0xFE, 0x97, 0xFE, 0xFF, 0x68, 0xFE, 0x97, 0xFE, 0xFF, 0x68},
{0xD2, 0x97, 0xFE, 0xFF, 0x52, 0xD2, 0x97, 0xFE, 0xFF, 0x52},
{0xD2, 0x97, 0xFE, 0xFF, 0x52, 0xD2, 0x97, 0xFE, 0xFF, 0x52},
{0xD2, 0x97, 0xFE, 0xFF, 0x52, 0xD2, 0x97, 0xFE, 0xFF, 0x52},
{0xE8, 0x97, 0xFE, 0xFF, 0x7E, 0xE8, 0x97, 0xFE, 0xFF, 0x7E},
{0xE8, 0x97, 0xFE, 0xFF, 0x7E, 0xE8, 0x97, 0xFE, 0xFF, 0x7E},
{0xC7, 0x17, 0xFE, 0xFF, 0xCD, 0xC7, 0x17, 0xFE, 0xFF, 0xCD},
{0xC7, 0x17, 0xFE, 0xFF, 0xCD, 0xC7, 0x17, 0xFE, 0xFF, 0xCD},
{0xC7, 0x17, 0xFE, 0xFF, 0xCD, 0xC7, 0x17, 0xFE, 0xFF, 0xCD},
{0xF5, 0x17, 0xFE, 0xFF, 0xE7, 0xF5, 0x17, 0xFE, 0xFF, 0xE7},
{0xF5, 0x17, 0xFE, 0xFF, 0xE7, 0xF5, 0x17, 0xFE, 0xFF, 0xE7},
{0xDE, 0x17, 0xFE, 0xFF, 0xD8, 0xDE, 0x17, 0xFE, 0xFF, 0xD8},
{0xDE, 0x17, 0xFE, 0xFF, 0xD8, 0xDE, 0x17, 0xFE, 0xFF, 0xD8},
{0xDE, 0x17, 0xFE, 0xFF, 0xD8, 0xDE, 0x17, 0xFE, 0xFF, 0xD8},
{0xE2, 0x17, 0xFE, 0xFF, 0xF2, 0xE2, 0x17, 0xFE, 0xFF, 0xF2},
{0xE2, 0x17, 0xFE, 0xFF, 0xF2, 0xE2, 0x17, 0xFE, 0xFF, 0xF2},
{0xC8, 0x17, 0xFE, 0xFF, 0xC1, 0xC8, 0x17, 0xFE, 0xFF, 0xC1},
{0xC8, 0x17, 0xFE, 0xFF, 0xC1, 0xC8, 0x17, 0xFE, 0xFF, 0xC1},
{0xC8, 0x17, 0xFE, 0xFF, 0xC1, 0xC8, 0x17, 0xFE, 0xFF, 0xC1},
{0xFB, 0xE7, 0xFE, 0xFF, 0x1D, 0xFB, 0xE7, 0xFE, 0xFF, 0x1D},
{0xFB, 0xE7, 0xFE, 0xFF, 0x1D, 0xFB, 0xE7, 0xFE, 0xFF, 0x1D},
{0xD5, 0xE7, 0xFE, 0xFF, 0x37, 0xD5, 0xE7, 0xFE, 0xFF, 0x37}};

// Variables
byte receivedData[packetSize];  // Buffer to store received data
unsigned long lastPacketTime = 0; // Last time a packet was received
bool receivingPacket = false;     // Are we currently receiving a packet?

void setup() {
  pinMode(clockPin, INPUT);       // Set the clock pin as input
  pinMode(dataInPin, INPUT);      // Set the data input pin as input
  pinMode(dataOutPin, OUTPUT);    // Set the data output pin as output
  pinMode(chipSelectPin, OUTPUT);    // Set the data output pin as output
  Serial.begin(9600);             // Start serial communication for debugging
  digitalWrite(dataOutPin, LOW);  // Initialize data output to low
  digitalWrite(chipSelectPin, LOW);  // Initialize data output to low
}

int responseDataSent = 0;
int responseDataIndex = 0;

void loop() {
  unsigned long currentTime = micros();

  // Check for the 80ms gap and the first clock pulse (active low)
  if (!receivingPacket && (currentTime - lastPacketTime >= packetGapTime) && digitalRead(clockPin) == HIGH) {
    // Ready to receive a new packet
    receivingPacket = true;
    lastPacketTime = currentTime; // Reset the last packet time
    receiveAndRespondPacket();
  }

  if (!receivingPacket && (currentTime - lastPacketTime >= packetGapTime/2) && digitalRead(clockPin) == LOW) {
          if (responseDataSent >= 2)
      {
            digitalWrite(chipSelectPin, HIGH);
      }
      else
      {
            digitalWrite(chipSelectPin, LOW);
      }
  }
}

void receiveAndRespondPacket() {
  unsigned long startTime = micros();

  for (int byteIndex = 0; byteIndex < packetSize; byteIndex++) {
    byte receivedByte = 0;

    // Read 8 bits (1 byte) from the data line, synchronized with clock
    for (int bitIndex = 0; bitIndex < 8; bitIndex++) {
      //waitForClockPulse();       // Wait for the clock to go low (active low)
        // Wait for the clock to go low (active low)
  while (digitalRead(clockPin) == LOW) {
    // Wait for clock to go low
  }
        // Send corresponding bit from the response byte
      bool responseBit = (responseData[responseDataIndex][byteIndex] >> (7 - bitIndex)) & 1;
      digitalWrite(dataOutPin, responseBit ? LOW : HIGH);
  // Wait for half the clock cycle to synchronize bit read
  delayMicroseconds(clockCycleTime / 2);
      receivedByte <<= 1;        // Shift left to make space for the new bit
      if (digitalRead(dataInPin) == HIGH) {
        receivedByte |= 1;       // Set the bit if the data input pin is high
      }



      // Wait for the clock to complete its cycle
      waitForClockReturn();
    }

    // Store the received byte in the buffer
    receivedData[byteIndex] = receivedByte;

    // Wait for the remainder of the 26ms per byte, if needed
    while (micros() - startTime < byteReceiveTime * (byteIndex + 1)) {
      // Waiting until time for the next byte
    }
    if (byteIndex < (packetSize -1))
    {
    digitalWrite(dataOutPin, LOW);
    }
  }

  receivingPacket = false;
  lastPacketTime = micros();  // Update the last packet time

      responseDataSent++;
      responseDataIndex++;

  // Debugging: Print the received packet
  Serial.print("Received Packet: ");
  for (int i = 0; i < packetSize; i++) {
    Serial.print(receivedData[i], HEX);
    Serial.print(" ");
  }
  Serial.println();
}

void waitForClockPulse() {
  // Wait for the clock to go low (active low)
  while (digitalRead(clockPin) == LOW) {
    // Wait for clock to go low
  }
  // Wait for half the clock cycle to synchronize bit read
  delayMicroseconds(clockCycleTime / 2);
}

void waitForClockReturn() {
  // Wait for clock to go high to complete the cycle
  while (digitalRead(clockPin) == HIGH) {
    // Wait for clock to go high
  }
}